<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>究極の木製パズル The-T</title>
    <style>
        :root {
            --wood: #8d6e63;
            --wood-dark: #4e342e;
            --accent: #ff5722;
            --bg: #f5f5dc;
        }

        body {
            margin: 0; padding: 0; background: var(--bg);
            font-family: sans-serif; overflow: hidden; touch-action: none; height: 100vh;
            display: flex; flex-direction: column;
        }

        #header {
            flex: 0 0 auto; background: var(--wood-dark); color: white;
            padding: 10px; text-align: center; z-index: 100;
        }

        #stage { flex: 1 1 auto; position: relative; width: 100%; overflow: hidden; }

        /* Tのシルエット（正解の大きさ） */
        #target-outline {
            position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%);
            width: 160px; height: 200px; /* Tの縦横比 */
            border: 2px dashed rgba(0,0,0,0.1); pointer-events: none;
        }

        .piece {
            position: absolute; cursor: move; background: var(--wood);
            background-image: repeating-linear-gradient(45deg, rgba(0,0,0,0.05) 0px, rgba(0,0,0,0.05) 2px, transparent 2px, transparent 4px);
            box-shadow: 3px 5px 10px rgba(0,0,0,0.3);
            transform-origin: 0 0;
            transition: transform 0.1s;
        }
        .piece.answering { transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1); z-index: 500; }

        /* The-T 黄金比ピース設計 (40pxを1ユニットとする) */
        /* P1: 小さな等辺台形 */
        #p1 { width: 120px; height: 40px; clip-path: polygon(0 0, 120px 0, 80px 40px, 40px 40px); }
        /* P2: 大きな台形 (これが肝) */
        #p3 { width: 120px; height: 80px; clip-path: polygon(0 0, 80px 0, 120px 40px, 120px 80px, 0 80px); }
        /* P3: 歪んだ五角形 */
        #p2 { width: 80px; height: 120px; clip-path: polygon(0 0, 80px 0, 80px 120px, 40px 80px, 0 80px); }
        /* P4: 小さな三角形 */
        #p4 { width: 80px; height: 40px; clip-path: polygon(0 0, 80px 40px, 0 40px); }

        .fixed { opacity: 0.6; pointer-events: none; }

        #footer {
            flex: 0 0 auto; background: var(--wood-dark); color: white;
            padding: 10px; text-align: center; font-size: 0.8rem;
        }
        
        .btn { padding: 6px 12px; margin: 2px; border: 1px solid #fff; border-radius: 4px; background: transparent; color: white; }
        .btn.active { background: var(--accent); }
        
        #overlay {
            display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9);
            z-index: 2000; color: gold; flex-direction: column; justify-content: center; align-items: center;
        }
    </style>
</head>
<body>

<div id="header">
    <div style="font-weight:bold; color:#ffccbc;">全てのピースを使って「T」を作ろう</div>
    <div style="margin: 5px 0;">TIME: <span id="timer">--</span></div>
    <div>
        <button class="btn" id="btn-beginner" onclick="setMode('beginner')">超初級</button>
        <button class="btn active" id="btn-easy" onclick="setMode('easy')">初級</button>
        <button class="btn" onclick="reveal()">答えを表示</button>
    </div>
</div>

<div id="stage">
    <div id="target-outline"></div>
    <div id="p1" class="piece" data-id="1"></div>
    <div id="p2" class="piece" data-id="2"></div>
    <div id="p3" class="piece" data-id="3"></div>
    <div id="p4" class="piece" data-id="4"></div>
</div>

<div id="footer">ドラッグ：移動 ／ ダブルタップ：回転</div>

<div id="overlay">
    <h2 id="win-msg">天才！！</h2>
    <button class="btn" style="background:var(--accent); font-size:1.2rem; padding:10px 20px;" onclick="reset()">再挑戦</button>
</div>

<script>
    const state = { 1:{x:0,y:0,r:0}, 2:{x:0,y:0,r:0}, 3:{x:0,y:0,r:0}, 4:{x:0,y:0,r:0} };
    
    // 数学的に正しいTの字の構成 (40pxグリッド)
    const solution = {
        1: { x: 20, y: 0, r: 0 },    // 横棒の上側
        2: { x: 60, y: 80, r: 0 },   // 縦棒の右側
        3: { x: 20, y: 40, r: 0 },   // 縦棒の左側 + 横棒の下側
        4: { x: 100, y: 40, r: 0 }   // 横棒の右端
    };

    let mode = 'easy';
    let timer = 120;
    let timerInt;
    let activeP = null;
    let offset = {x:0, y:0};

    function init() {
        document.querySelectorAll('.piece').forEach(p => {
            p.addEventListener('touchstart', startDrag, {passive:false});
            p.addEventListener('mousedown', startDrag);
            let last = 0;
            p.addEventListener('touchend', e => {
                if(Date.now()-last < 300) rotate(p);
                last = Date.now();
                stopDrag();
            });
            p.addEventListener('dblclick', () => rotate(p));
        });
        window.addEventListener('mousemove', doDrag);
        window.addEventListener('touchmove', doDrag, {passive:false});
        window.addEventListener('mouseup', stopDrag);
        reset();
    }

    function setMode(m) {
        mode = m;
        document.getElementById('btn-beginner').className = m==='beginner'?'btn active':'btn';
        document.getElementById('btn-easy').className = m==='easy'?'btn active':'btn';
        reset();
    }

    function reset() {
        document.getElementById('overlay').style.display='none';
        const s = document.getElementById('stage').getBoundingClientRect();
        const t = document.getElementById('target-outline').getBoundingClientRect();
        
        Object.keys(state).forEach((id, i) => {
            const p = document.querySelector(`[data-id="${id}"]`);
            p.classList.remove('fixed','answering');
            if(mode==='beginner' && id==='3') {
                state[id].x = t.left + solution[id].x;
                state[id].y = t.top - s.top + solution[id].y;
                state[id].r = solution[id].r;
                p.classList.add('fixed');
            } else {
                state[id].x = (s.width/4)*i + 20;
                state[id].y = s.height - 150;
                state[id].r = Math.floor(Math.random()*4)*90;
            }
            update(id);
        });
        timer = 120;
        clearInterval(timerInt);
        timerInt = setInterval(() => {
            timer--;
            document.getElementById('timer').innerText = timer + "s";
            if(timer<=0) { clearInterval(timerInt); alert("Time Up!"); reset(); }
        }, 1000);
    }

    function reveal() {
        const s = document.getElementById('stage').getBoundingClientRect();
        const t = document.getElementById('target-outline').getBoundingClientRect();
        Object.keys(solution).forEach(id => {
            const p = document.querySelector(`[data-id="${id}"]`);
            p.classList.add('answering');
            state[id].x = t.left + solution[id].x;
            state[id].y = t.top - s.top + solution[id].y;
            state[id].r = solution[id].r;
            update(id);
        });
        setTimeout(() => { document.getElementById('overlay').style.display='flex'; }, 1000);
    }

    function startDrag(e) {
        if(e.target.classList.contains('fixed')) return;
        activeP = e.target;
        const p = e.touches ? e.touches[0] : e;
        const id = activeP.dataset.id;
        offset.x = p.clientX - state[id].x;
        offset.y = p.clientY - state[id].y;
        activeP.style.zIndex = 1000;
    }

    function doDrag(e) {
        if(!activeP) return;
        const p = e.touches ? e.touches[0] : e;
        const id = activeP.dataset.id;
        state[id].x = p.clientX - offset.x;
        state[id].y = p.clientY - offset.y;
        update(id);
    }

    function stopDrag() {
        if(activeP) { activeP.style.zIndex = 10; check(); }
        activeP = null;
    }

    function rotate(p) {
        if(p.classList.contains('fixed')) return;
        const id = p.dataset.id;
        state[id].r = (state[id].r + 90) % 360;
        update(id);
        check();
    }

    function update(id) {
        const p = document.querySelector(`[data-id="${id}"]`);
        p.style.transform = `translate(${state[id].x}px, ${state[id].y}px) rotate(${state[id].r}deg)`;
    }

    function check() {
        const s = document.getElementById('stage').getBoundingClientRect();
        const t = document.getElementById('target-outline').getBoundingClientRect();
        let ok = 0;
        Object.keys(solution).forEach(id => {
            const dx = (state[id].x - t.left) - solution[id].x;
            const dy = (state[id].y - (t.top - s.top)) - solution[id].y;
            if(Math.abs(dx)<15 && Math.abs(dy)<15 && state[id].r % 360 === solution[id].r) ok++;
        });
        if(ok===4) {
            clearInterval(timerInt);
            document.getElementById('overlay').style.display='flex';
        }
    }

    init();
</script>
</body>
</html>